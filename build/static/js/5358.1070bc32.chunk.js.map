{"version":3,"file":"static/js/5358.1070bc32.chunk.js","mappings":"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","sources":["../node_modules/viem/utils/abi/getAbiItem.ts","../node_modules/viem/errors/address.ts","../node_modules/viem/utils/regex.ts","../node_modules/viem/utils/abi/prepareEncodeFunctionData.ts","../node_modules/viem/utils/abi/encodeFunctionData.ts","../node_modules/viem/utils/hash/toEventSelector.ts","../node_modules/viem/utils/abi/encodeAbiParameters.ts","../node_modules/viem/utils/data/slice.ts","../node_modules/viem/utils/encoding/toBytes.ts","../node_modules/viem/node_modules/abitype/src/regex.ts","../node_modules/viem/utils/address/getAddress.ts","../node_modules/viem/utils/hash/hashSignature.ts","../node_modules/viem/utils/hash/toSignature.ts","../node_modules/viem/utils/hash/normalizeSignature.ts","../node_modules/viem/utils/hash/toSignatureHash.ts","../node_modules/viem/utils/data/concat.ts","../node_modules/viem/utils/abi/formatAbiItem.ts","../node_modules/viem/utils/hash/toFunctionSelector.ts","../node_modules/viem/utils/address/isAddress.ts","../node_modules/viem/node_modules/abitype/src/human-readable/formatAbiParameter.ts","../node_modules/viem/node_modules/abitype/src/human-readable/formatAbiParameters.ts","../node_modules/viem/constants/strings.ts","../node_modules/viem/utils/signature/hashMessage.ts","../node_modules/viem/utils/signature/toPrefixedMessage.ts","../node_modules/viem/node_modules/abitype/src/human-readable/formatAbiItem.ts","../node_modules/viem/utils/hash/keccak256.ts","../node_modules/viem/errors/typedData.ts","../node_modules/viem/utils/typedData.ts","../node_modules/viem/utils/signature/hashTypedData.ts","../node_modules/viem/errors/abi.ts"],"sourcesContent":["import type { Abi, AbiParameter, Address } from 'abitype'\n\nimport {\n  AbiItemAmbiguityError,\n  type AbiItemAmbiguityErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  AbiItem,\n  AbiItemArgs,\n  AbiItemName,\n  ExtractAbiItemForArgs,\n  Widen,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { UnionEvaluate } from '../../types/utils.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { toEventSelector } from '../hash/toEventSelector.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\n\nexport type GetAbiItemParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n  ///\n  allArgs = AbiItemArgs<abi, name>,\n  allNames = AbiItemName<abi>,\n> = {\n  abi: abi\n  name:\n    | allNames // show all options\n    | (name extends allNames ? name : never) // infer value\n    | Hex // function selector\n} & UnionEvaluate<\n  readonly [] extends allArgs\n    ? {\n        args?:\n          | allArgs // show all options\n          // infer value, widen inferred value of `args` conditionally to match `allArgs`\n          | (abi extends Abi\n              ? args extends allArgs\n                ? Widen<args>\n                : never\n              : never)\n          | undefined\n      }\n    : {\n        args?:\n          | allArgs // show all options\n          | (Widen<args> & (args extends allArgs ? unknown : never)) // infer value, widen inferred value of `args` match `allArgs` (e.g. avoid union `args: readonly [123n] | readonly [bigint]`)\n          | undefined\n      }\n>\n\nexport type GetAbiItemErrorType =\n  | IsArgOfTypeErrorType\n  | IsHexErrorType\n  | ToFunctionSelectorErrorType\n  | AbiItemAmbiguityErrorType\n  | ErrorType\n\nexport type GetAbiItemReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n> = abi extends Abi\n  ? Abi extends abi\n    ? AbiItem | undefined\n    : ExtractAbiItemForArgs<\n        abi,\n        name,\n        args extends AbiItemArgs<abi, name> ? args : AbiItemArgs<abi, name>\n      >\n  : AbiItem | undefined\n\nexport function getAbiItem<\n  const abi extends Abi | readonly unknown[],\n  name extends AbiItemName<abi>,\n  const args extends AbiItemArgs<abi, name> | undefined = undefined,\n>(\n  parameters: GetAbiItemParameters<abi, name, args>,\n): GetAbiItemReturnType<abi, name, args> {\n  const { abi, args = [], name } = parameters as unknown as GetAbiItemParameters\n\n  const isSelector = isHex(name, { strict: false })\n  const abiItems = (abi as Abi).filter((abiItem) => {\n    if (isSelector) {\n      if (abiItem.type === 'function')\n        return toFunctionSelector(abiItem) === name\n      if (abiItem.type === 'event') return toEventSelector(abiItem) === name\n      return false\n    }\n    return 'name' in abiItem && abiItem.name === name\n  })\n\n  if (abiItems.length === 0)\n    return undefined as GetAbiItemReturnType<abi, name, args>\n  if (abiItems.length === 1)\n    return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n\n  let matchedAbiItem: AbiItem | undefined\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0)\n        return abiItem as GetAbiItemReturnType<abi, name, args>\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    if (abiItem.inputs.length !== args.length) continue\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return isArgOfType(arg, abiParameter)\n    })\n    if (matched) {\n      // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n      if (\n        matchedAbiItem &&\n        'inputs' in matchedAbiItem &&\n        matchedAbiItem.inputs\n      ) {\n        const ambiguousTypes = getAmbiguousTypes(\n          abiItem.inputs,\n          matchedAbiItem.inputs,\n          args as readonly unknown[],\n        )\n        if (ambiguousTypes)\n          throw new AbiItemAmbiguityError(\n            {\n              abiItem,\n              type: ambiguousTypes[0],\n            },\n            {\n              abiItem: matchedAbiItem,\n              type: ambiguousTypes[1],\n            },\n          )\n      }\n\n      matchedAbiItem = abiItem\n    }\n  }\n\n  if (matchedAbiItem)\n    return matchedAbiItem as GetAbiItemReturnType<abi, name, args>\n  return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n}\n\ntype IsArgOfTypeErrorType = IsAddressErrorType | ErrorType\n\n/** @internal */\nexport function isArgOfType(arg: unknown, abiParameter: AbiParameter): boolean {\n  const argType = typeof arg\n  const abiParameterType = abiParameter.type\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg as Address, { strict: false })\n    case 'bool':\n      return argType === 'boolean'\n    case 'function':\n      return argType === 'string'\n    case 'string':\n      return argType === 'string'\n    default: {\n      if (abiParameterType === 'tuple' && 'components' in abiParameter)\n        return Object.values(abiParameter.components).every(\n          (component, index) => {\n            return isArgOfType(\n              Object.values(arg as unknown[] | Record<string, unknown>)[index],\n              component as AbiParameter,\n            )\n          },\n        )\n\n      // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n      // https://regexr.com/6v8hp\n      if (\n        /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(\n          abiParameterType,\n        )\n      )\n        return argType === 'number' || argType === 'bigint'\n\n      // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n      // https://regexr.com/6va55\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === 'string' || arg instanceof Uint8Array\n\n      // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n      // https://regexr.com/6va6i\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return (\n          Array.isArray(arg) &&\n          arg.every((x: unknown) =>\n            isArgOfType(x, {\n              ...abiParameter,\n              // Pop off `[]` or `[M]` from end of type\n              type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n            } as AbiParameter),\n          )\n        )\n      }\n\n      return false\n    }\n  }\n}\n\n/** @internal */\nexport function getAmbiguousTypes(\n  sourceParameters: readonly AbiParameter[],\n  targetParameters: readonly AbiParameter[],\n  args: AbiItemArgs,\n): AbiParameter['type'][] | undefined {\n  for (const parameterIndex in sourceParameters) {\n    const sourceParameter = sourceParameters[parameterIndex]\n    const targetParameter = targetParameters[parameterIndex]\n\n    if (\n      sourceParameter.type === 'tuple' &&\n      targetParameter.type === 'tuple' &&\n      'components' in sourceParameter &&\n      'components' in targetParameter\n    )\n      return getAmbiguousTypes(\n        sourceParameter.components,\n        targetParameter.components,\n        (args as any)[parameterIndex],\n      )\n\n    const types = [sourceParameter.type, targetParameter.type]\n\n    const ambiguous = (() => {\n      if (types.includes('address') && types.includes('bytes20')) return true\n      if (types.includes('address') && types.includes('string'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      if (types.includes('address') && types.includes('bytes'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      return false\n    })()\n\n    if (ambiguous) return types\n  }\n\n  return\n}\n","import { BaseError } from './base.js'\n\nexport type InvalidAddressErrorType = InvalidAddressError & {\n  name: 'InvalidAddressError'\n}\nexport class InvalidAddressError extends BaseError {\n  constructor({ address }: { address: string }) {\n    super(`Address \"${address}\" is invalid.`, {\n      metaMessages: [\n        '- Address must be a hex value of 20 bytes (40 hex characters).',\n        '- Address must match its checksum counterpart.',\n      ],\n      name: 'InvalidAddressError',\n    })\n  }\n}\n","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n","import type {\n  Abi,\n  AbiStateMutability,\n  ExtractAbiFunction,\n  ExtractAbiFunctions,\n} from 'abitype'\n\nimport {\n  AbiFunctionNotFoundError,\n  type AbiFunctionNotFoundErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport type { ConcatHexErrorType } from '../data/concat.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeFunctionData'\n\nexport type PrepareEncodeFunctionDataParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | undefined = ContractFunctionName<abi>,\n  ///\n  hasFunctions = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiFunctions<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractFunctionArgs<\n    abi,\n    AbiStateMutability,\n    functionName extends ContractFunctionName<abi>\n      ? functionName\n      : ContractFunctionName<abi>\n  >,\n  allFunctionNames = ContractFunctionName<abi>,\n> = {\n  abi: abi\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { functionName?: functionName | allFunctionNames | Hex | undefined }\n      : { functionName: functionName | allFunctionNames | Hex }\n    : { functionName?: functionName | allFunctionNames | Hex | undefined }\n> &\n  UnionEvaluate<{ args?: allArgs | undefined }> &\n  (hasFunctions extends true ? unknown : never)\n\nexport type PrepareEncodeFunctionDataReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | undefined = ContractFunctionName<abi>,\n> = {\n  abi: abi extends Abi\n    ? functionName extends ContractFunctionName<abi>\n      ? [ExtractAbiFunction<abi, functionName>]\n      : abi\n    : Abi\n  functionName: Hex\n}\n\nexport type PrepareEncodeFunctionDataErrorType =\n  | AbiFunctionNotFoundErrorType\n  | ConcatHexErrorType\n  | FormatAbiItemErrorType\n  | GetAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | ErrorType\n\nexport function prepareEncodeFunctionData<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi> | undefined = undefined,\n>(\n  parameters: PrepareEncodeFunctionDataParameters<abi, functionName>,\n): PrepareEncodeFunctionDataReturnType<abi, functionName> {\n  const { abi, args, functionName } =\n    parameters as PrepareEncodeFunctionDataParameters\n\n  let abiItem = abi[0]\n  if (functionName) {\n    const item = getAbiItem({\n      abi,\n      args,\n      name: functionName,\n    })\n    if (!item) throw new AbiFunctionNotFoundError(functionName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'function')\n    throw new AbiFunctionNotFoundError(undefined, { docsPath })\n\n  return {\n    abi: [abiItem],\n    functionName: toFunctionSelector(formatAbiItem(abiItem)),\n  } as unknown as PrepareEncodeFunctionDataReturnType<abi, functionName>\n}\n","import type { Abi, AbiStateMutability, ExtractAbiFunctions } from 'abitype'\n\nimport type { AbiFunctionNotFoundErrorType } from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport type { ToFunctionSelectorErrorType } from '../hash/toFunctionSelector.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport type { FormatAbiItemErrorType } from './formatAbiItem.js'\nimport type { GetAbiItemErrorType } from './getAbiItem.js'\nimport { prepareEncodeFunctionData } from './prepareEncodeFunctionData.js'\n\nexport type EncodeFunctionDataParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | Hex\n    | undefined = ContractFunctionName<abi>,\n  ///\n  hasFunctions = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiFunctions<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractFunctionArgs<\n    abi,\n    AbiStateMutability,\n    functionName extends ContractFunctionName<abi>\n      ? functionName\n      : ContractFunctionName<abi>\n  >,\n  allFunctionNames = ContractFunctionName<abi>,\n> = {\n  abi: abi\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { functionName?: functionName | allFunctionNames | Hex | undefined }\n      : { functionName: functionName | allFunctionNames | Hex }\n    : { functionName?: functionName | allFunctionNames | Hex | undefined }\n> &\n  UnionEvaluate<\n    readonly [] extends allArgs\n      ? { args?: allArgs | undefined }\n      : { args: allArgs }\n  > &\n  (hasFunctions extends true ? unknown : never)\n\nexport type EncodeFunctionDataReturnType = Hex\n\nexport type EncodeFunctionDataErrorType =\n  | AbiFunctionNotFoundErrorType\n  | ConcatHexErrorType\n  | EncodeAbiParametersErrorType\n  | FormatAbiItemErrorType\n  | GetAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | ErrorType\n\nexport function encodeFunctionData<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi> | undefined = undefined,\n>(\n  parameters: EncodeFunctionDataParameters<abi, functionName>,\n): EncodeFunctionDataReturnType {\n  const { args } = parameters as EncodeFunctionDataParameters\n\n  const { abi, functionName } = (() => {\n    if (\n      parameters.abi.length === 1 &&\n      parameters.functionName?.startsWith('0x')\n    )\n      return parameters as { abi: Abi; functionName: Hex }\n    return prepareEncodeFunctionData(parameters)\n  })()\n\n  const abiItem = abi[0]\n  const signature = functionName\n\n  const data =\n    'inputs' in abiItem && abiItem.inputs\n      ? encodeAbiParameters(abiItem.inputs, args ?? [])\n      : undefined\n  return concatHex([signature, data ?? '0x'])\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport {\n  type ToSignatureHashErrorType,\n  toSignatureHash,\n} from './toSignatureHash.js'\n\nexport type ToEventSelectorErrorType = ToSignatureHashErrorType | ErrorType\n\n/**\n * Returns the event selector for a given event definition.\n *\n * @example\n * const selector = toEventSelector('Transfer(address indexed from, address indexed to, uint256 amount)')\n * // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n */\nexport const toEventSelector = toSignatureHash\n","import type {\n  AbiParameter,\n  AbiParametersToPrimitiveTypes,\n  AbiParameterToPrimitiveType,\n} from 'abitype'\n\nimport {\n  AbiEncodingArrayLengthMismatchError,\n  type AbiEncodingArrayLengthMismatchErrorType,\n  AbiEncodingBytesSizeMismatchError,\n  type AbiEncodingBytesSizeMismatchErrorType,\n  AbiEncodingLengthMismatchError,\n  type AbiEncodingLengthMismatchErrorType,\n  InvalidAbiEncodingTypeError,\n  type InvalidAbiEncodingTypeErrorType,\n  InvalidArrayError,\n  type InvalidArrayErrorType,\n} from '../../errors/abi.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport { BaseError } from '../../errors/base.js'\nimport { IntegerOutOfRangeError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { type PadHexErrorType, padHex } from '../data/pad.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type BoolToHexErrorType,\n  boolToHex,\n  type NumberToHexErrorType,\n  numberToHex,\n  type StringToHexErrorType,\n  stringToHex,\n} from '../encoding/toHex.js'\nimport { integerRegex } from '../regex.js'\n\nexport type EncodeAbiParametersReturnType = Hex\n\nexport type EncodeAbiParametersErrorType =\n  | AbiEncodingLengthMismatchErrorType\n  | PrepareParamsErrorType\n  | EncodeParamsErrorType\n  | ErrorType\n\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n *\n * - Docs: https://viem.sh/docs/abi/encodeAbiParameters#encodeabiparameters\n *\n *   Generates ABI encoded data using the [ABI specification](https://docs.soliditylang.org/en/latest/abi-spec), given a set of ABI parameters (inputs/outputs) and their corresponding values.\n *\n * @param params - a set of ABI Parameters (params), that can be in the shape of the inputs or outputs attribute of an ABI Item.\n * @param values - a set of values (values) that correspond to the given params.\n * @example\n * ```typescript\n * import { encodeAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   [\n *     { name: 'x', type: 'string' },\n *     { name: 'y', type: 'uint' },\n *     { name: 'z', type: 'bool' }\n *   ],\n *   ['wagmi', 420n, true]\n * )\n * ```\n *\n * You can also pass in Human Readable parameters with the parseAbiParameters utility.\n *\n * @example\n * ```typescript\n * import { encodeAbiParameters, parseAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   parseAbiParameters('string x, uint y, bool z'),\n *   ['wagmi', 420n, true]\n * )\n * ```\n */\nexport function encodeAbiParameters<\n  const params extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: params,\n  values: params extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<params>\n    : never,\n): EncodeAbiParametersReturnType {\n  if (params.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: params.length as number,\n      givenLength: values.length as any,\n    })\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values: values as any,\n  })\n  const data = encodeParams(preparedParams)\n  if (data.length === 0) return '0x'\n  return data\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex }\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>\n\ntype PrepareParamsErrorType = PrepareParamErrorType | ErrorType\n\nfunction prepareParams<const params extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: params\n  values: AbiParametersToPrimitiveTypes<params>\n}) {\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < params.length; i++) {\n    preparedParams.push(prepareParam({ param: params[i], value: values[i] }))\n  }\n  return preparedParams\n}\n\ntype PrepareParamErrorType =\n  | EncodeAddressErrorType\n  | EncodeArrayErrorType\n  | EncodeBytesErrorType\n  | EncodeBoolErrorType\n  | EncodeNumberErrorType\n  | EncodeStringErrorType\n  | EncodeTupleErrorType\n  | GetArrayComponentsErrorType\n  | InvalidAbiEncodingTypeErrorType\n  | ErrorType\n\nfunction prepareParam<const param extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: param\n  value: AbiParameterToPrimitiveType<param>\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, { length, param: { ...param, type } })\n  }\n  if (param.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    })\n  }\n  if (param.type === 'address') {\n    return encodeAddress(value as unknown as Hex)\n  }\n  if (param.type === 'bool') {\n    return encodeBool(value as unknown as boolean)\n  }\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    const signed = param.type.startsWith('int')\n    const [, , size = '256'] = integerRegex.exec(param.type) ?? []\n    return encodeNumber(value as unknown as number, {\n      signed,\n      size: Number(size),\n    })\n  }\n  if (param.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex, { param })\n  }\n  if (param.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new InvalidAbiEncodingTypeError(param.type, {\n    docsPath: '/docs/contract/encodeAbiParameters',\n  })\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype EncodeParamsErrorType = NumberToHexErrorType | SizeErrorType | ErrorType\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) staticSize += 32\n    else staticSize += size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = []\n  const dynamicParams: Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }))\n      dynamicParams.push(encoded)\n      dynamicSize += size(encoded)\n    } else {\n      staticParams.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams])\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype EncodeAddressErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nfunction encodeAddress(value: Hex): PreparedParam {\n  if (!isAddress(value)) throw new InvalidAddressError({ address: value })\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) }\n}\n\ntype EncodeArrayErrorType =\n  | AbiEncodingArrayLengthMismatchErrorType\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  | InvalidArrayErrorType\n  | NumberToHexErrorType\n  // TODO: Add back once circular type reference is resolved\n  // | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeArray<const param extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<param>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null\n    param: param\n  },\n): PreparedParam {\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiEncodingArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${param.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParams.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams)\n    if (dynamic) {\n      const length = numberToHex(preparedParams.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\ntype EncodeBytesErrorType =\n  | AbiEncodingBytesSizeMismatchErrorType\n  | ConcatErrorType\n  | PadHexErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction encodeBytes<const param extends AbiParameter>(\n  value: Hex,\n  { param }: { param: param },\n): PreparedParam {\n  const [, paramSize] = param.type.split('bytes')\n  const bytesSize = size(value)\n  if (!paramSize) {\n    let value_ = value\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0)\n      value_ = padHex(value_, {\n        dir: 'right',\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      })\n    return {\n      dynamic: true,\n      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_]),\n    }\n  }\n  if (bytesSize !== Number.parseInt(paramSize, 10))\n    throw new AbiEncodingBytesSizeMismatchError({\n      expectedSize: Number.parseInt(paramSize, 10),\n      value,\n    })\n  return { dynamic: false, encoded: padHex(value, { dir: 'right' }) }\n}\n\ntype EncodeBoolErrorType = PadHexErrorType | BoolToHexErrorType | ErrorType\n\nfunction encodeBool(value: boolean): PreparedParam {\n  if (typeof value !== 'boolean')\n    throw new BaseError(\n      `Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`,\n    )\n  return { dynamic: false, encoded: padHex(boolToHex(value)) }\n}\n\ntype EncodeNumberErrorType = NumberToHexErrorType | ErrorType\n\nfunction encodeNumber(\n  value: number,\n  { signed, size = 256 }: { signed: boolean; size?: number | undefined },\n): PreparedParam {\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n\n    const min = signed ? -max - 1n : 0n\n    if (value > max || value < min)\n      throw new IntegerOutOfRangeError({\n        max: max.toString(),\n        min: min.toString(),\n        signed,\n        size: size / 8,\n        value: value.toString(),\n      })\n  }\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\ntype EncodeStringErrorType =\n  | ConcatErrorType\n  | NumberToHexErrorType\n  | PadHexErrorType\n  | SizeErrorType\n  | SliceErrorType\n  | StringToHexErrorType\n  | ErrorType\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value)\n  const partsLength = Math.ceil(size(hexValue) / 32)\n  const parts: Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: 'right',\n      }),\n    )\n  }\n  return {\n    dynamic: true,\n    encoded: concat([\n      padHex(numberToHex(size(hexValue), { size: 32 })),\n      ...parts,\n    ]),\n  }\n}\n\ntype EncodeTupleErrorType =\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  // TODO: Add back once circular type reference is resolved\n  // | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeTuple<\n  const param extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<param>,\n  { param }: { param: param },\n): PreparedParam {\n  let dynamic = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < param.components.length; i++) {\n    const param_ = param.components[i]\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParam({\n      param: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParams.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\ntype GetArrayComponentsErrorType = ErrorType\n\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\n    : undefined\n}\n","import {\n  SliceOffsetOutOfBoundsError,\n  type SliceOffsetOutOfBoundsErrorType,\n} from '../../errors/data.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { type IsHexErrorType, isHex } from './isHex.js'\nimport { type SizeErrorType, size } from './size.js'\n\nexport type SliceReturnType<value extends ByteArray | Hex> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type SliceErrorType =\n  | IsHexErrorType\n  | SliceBytesErrorType\n  | SliceHexErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice<value extends ByteArray | Hex>(\n  value: value,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): SliceReturnType<value> {\n  if (isHex(value, { strict: false }))\n    return sliceHex(value as Hex, start, end, {\n      strict,\n    }) as SliceReturnType<value>\n  return sliceBytes(value as ByteArray, start, end, {\n    strict,\n  }) as SliceReturnType<value>\n}\n\nexport type AssertStartOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertStartOffset(value: Hex | ByteArray, start?: number | undefined) {\n  if (typeof start === 'number' && start > 0 && start > size(value) - 1)\n    throw new SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: size(value),\n    })\n}\n\nexport type AssertEndOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertEndOffset(\n  value: Hex | ByteArray,\n  start?: number | undefined,\n  end?: number | undefined,\n) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    size(value) !== end - start\n  ) {\n    throw new SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: size(value),\n    })\n  }\n}\n\nexport type SliceBytesErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(\n  value_: ByteArray,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): ByteArray {\n  assertStartOffset(value_, start)\n  const value = value_.slice(start, end)\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n\nexport type SliceHexErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(\n  value_: Hex,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): Hex {\n  assertStartOffset(value_, start)\n  const value = `0x${value_\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}` as const\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\nimport {\n  type NumberToHexErrorType,\n  type NumberToHexOpts,\n  numberToHex,\n} from './toHex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nexport type ToBytesParameters = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type ToBytesErrorType =\n  | NumberToBytesErrorType\n  | BoolToBytesErrorType\n  | HexToBytesErrorType\n  | StringToBytesErrorType\n  | IsHexErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes\n * - Example: https://viem.sh/docs/utilities/toBytes#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(\n  value: string | bigint | number | boolean | Hex,\n  opts: ToBytesParameters = {},\n): ByteArray {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToBytes(value, opts)\n  if (typeof value === 'boolean') return boolToBytes(value, opts)\n  if (isHex(value)) return hexToBytes(value, opts)\n  return stringToBytes(value, opts)\n}\n\nexport type BoolToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type BoolToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value: boolean, opts: BoolToBytesOpts = {}) {\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { size: opts.size })\n  }\n  return bytes\n}\n\n// We use very optimized technique to convert hex string to byte array\nconst charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102,\n} as const\n\nfunction charCodeToBase16(char: number) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n    return char - charCodeMap.zero\n  if (char >= charCodeMap.A && char <= charCodeMap.F)\n    return char - (charCodeMap.A - 10)\n  if (char >= charCodeMap.a && char <= charCodeMap.f)\n    return char - (charCodeMap.a - 10)\n  return undefined\n}\n\nexport type HexToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type HexToBytesErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_: Hex, opts: HexToBytesOpts = {}): ByteArray {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = pad(hex, { dir: 'right', size: opts.size })\n  }\n\n  let hexString = hex.slice(2) as string\n  if (hexString.length % 2) hexString = `0${hexString}`\n\n  const length = hexString.length / 2\n  const bytes = new Uint8Array(length)\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++))\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++))\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new BaseError(\n        `Invalid byte sequence (\"${hexString[j - 2]}${\n          hexString[j - 1]\n        }\" in \"${hexString}\").`,\n      )\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight\n  }\n  return bytes\n}\n\nexport type NumberToBytesErrorType =\n  | NumberToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(\n  value: bigint | number,\n  opts?: NumberToHexOpts | undefined,\n) {\n  const hex = numberToHex(value, opts)\n  return hexToBytes(hex)\n}\n\nexport type StringToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type StringToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(\n  value: string,\n  opts: StringToBytesOpts = {},\n): ByteArray {\n  const bytes = encoder.encode(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { dir: 'right', size: opts.size })\n  }\n  return bytes\n}\n","// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped<type>(regex: RegExp, string: string) {\n  const match = regex.exec(string)\n  return match?.groups as type | undefined\n}\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const isTupleRegex = /^\\(.+?\\).*?$/\n","import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n} from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { LruMap } from '../lru.js'\nimport { type IsAddressErrorType, isAddress } from './isAddress.js'\n\nconst checksumAddressCache = /*#__PURE__*/ new LruMap<Address>(8192)\n\nexport type ChecksumAddressErrorType =\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ErrorType\n\nexport function checksumAddress(\n  address_: Address,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number | undefined,\n): Address {\n  if (checksumAddressCache.has(`${address_}.${chainId}`))\n    return checksumAddressCache.get(`${address_}.${chainId}`)!\n\n  const hexAddress = chainId\n    ? `${chainId}${address_.toLowerCase()}`\n    : address_.substring(2).toLowerCase()\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes')\n\n  const address = (\n    chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress\n  ).split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase()\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase()\n    }\n  }\n\n  const result = `0x${address.join('')}` as const\n  checksumAddressCache.set(`${address_}.${chainId}`, result)\n  return result\n}\n\nexport type GetAddressErrorType =\n  | ChecksumAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nexport function getAddress(\n  address: string,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number,\n): Address {\n  if (!isAddress(address, { strict: false }))\n    throw new InvalidAddressError({ address })\n  return checksumAddress(address, chainId)\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from './keccak256.js'\n\nconst hash = (value: string) => keccak256(toBytes(value))\n\nexport type HashSignatureErrorType =\n  | Keccak256ErrorType\n  | ToBytesErrorType\n  | ErrorType\n\nexport function hashSignature(sig: string) {\n  return hash(sig)\n}\n","import { type AbiEvent, type AbiFunction, formatAbiItem } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type NormalizeSignatureErrorType,\n  normalizeSignature,\n} from './normalizeSignature.js'\n\nexport type ToSignatureErrorType = NormalizeSignatureErrorType | ErrorType\n\n/**\n * Returns the signature for a given function or event definition.\n *\n * @example\n * const signature = toSignature('function ownerOf(uint256 tokenId)')\n * // 'ownerOf(uint256)'\n *\n * @example\n * const signature_3 = toSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // 'ownerOf(uint256)'\n */\nexport const toSignature = (def: string | AbiFunction | AbiEvent) => {\n  const def_ = (() => {\n    if (typeof def === 'string') return def\n    return formatAbiItem(def)\n  })()\n  return normalizeSignature(def_)\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\n\ntype NormalizeSignatureParameters = string\ntype NormalizeSignatureReturnType = string\nexport type NormalizeSignatureErrorType = ErrorType\n\nexport function normalizeSignature(\n  signature: NormalizeSignatureParameters,\n): NormalizeSignatureReturnType {\n  let active = true\n  let current = ''\n  let level = 0\n  let result = ''\n  let valid = false\n\n  for (let i = 0; i < signature.length; i++) {\n    const char = signature[i]\n\n    // If the character is a separator, we want to reactivate.\n    if (['(', ')', ','].includes(char)) active = true\n\n    // If the character is a \"level\" token, we want to increment/decrement.\n    if (char === '(') level++\n    if (char === ')') level--\n\n    // If we aren't active, we don't want to mutate the result.\n    if (!active) continue\n\n    // If level === 0, we are at the definition level.\n    if (level === 0) {\n      if (char === ' ' && ['event', 'function', ''].includes(result))\n        result = ''\n      else {\n        result += char\n\n        // If we are at the end of the definition, we must be finished.\n        if (char === ')') {\n          valid = true\n          break\n        }\n      }\n\n      continue\n    }\n\n    // Ignore spaces\n    if (char === ' ') {\n      // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n      if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n        current = ''\n        active = false\n      }\n      continue\n    }\n\n    result += char\n    current += char\n  }\n\n  if (!valid) throw new BaseError('Unable to normalize signature.')\n\n  return result\n}\n","import type { AbiEvent, AbiFunction } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type HashSignatureErrorType, hashSignature } from './hashSignature.js'\nimport { type ToSignatureErrorType, toSignature } from './toSignature.js'\n\nexport type ToSignatureHashErrorType =\n  | HashSignatureErrorType\n  | ToSignatureErrorType\n  | ErrorType\n\n/**\n * Returns the hash (of the function/event signature) for a given event or function definition.\n */\nexport function toSignatureHash(fn: string | AbiFunction | AbiEvent) {\n  return hashSignature(toSignature(fn))\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nexport type ConcatReturnType<value extends Hex | ByteArray> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type ConcatErrorType =\n  | ConcatBytesErrorType\n  | ConcatHexErrorType\n  | ErrorType\n\nexport function concat<value extends Hex | ByteArray>(\n  values: readonly value[],\n): ConcatReturnType<value> {\n  if (typeof values[0] === 'string')\n    return concatHex(values as readonly Hex[]) as ConcatReturnType<value>\n  return concatBytes(values as readonly ByteArray[]) as ConcatReturnType<value>\n}\n\nexport type ConcatBytesErrorType = ErrorType\n\nexport function concatBytes(values: readonly ByteArray[]): ByteArray {\n  let length = 0\n  for (const arr of values) {\n    length += arr.length\n  }\n  const result = new Uint8Array(length)\n  let offset = 0\n  for (const arr of values) {\n    result.set(arr, offset)\n    offset += arr.length\n  }\n  return result\n}\n\nexport type ConcatHexErrorType = ErrorType\n\nexport function concatHex(values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce(\n    (acc, x) => acc + x.replace('0x', ''),\n    '',\n  )}`\n}\n","import type { AbiParameter } from 'abitype'\n\nimport {\n  InvalidDefinitionTypeError,\n  type InvalidDefinitionTypeErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { AbiItem } from '../../types/contract.js'\n\nexport type FormatAbiItemErrorType =\n  | FormatAbiParamsErrorType\n  | InvalidDefinitionTypeErrorType\n  | ErrorType\n\nexport function formatAbiItem(\n  abiItem: AbiItem,\n  { includeName = false }: { includeName?: boolean | undefined } = {},\n) {\n  if (\n    abiItem.type !== 'function' &&\n    abiItem.type !== 'event' &&\n    abiItem.type !== 'error'\n  )\n    throw new InvalidDefinitionTypeError(abiItem.type)\n\n  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`\n}\n\nexport type FormatAbiParamsErrorType = ErrorType\n\nexport function formatAbiParams(\n  params: readonly AbiParameter[] | undefined,\n  { includeName = false }: { includeName?: boolean | undefined } = {},\n): string {\n  if (!params) return ''\n  return params\n    .map((param) => formatAbiParam(param, { includeName }))\n    .join(includeName ? ', ' : ',')\n}\n\nexport type FormatAbiParamErrorType = ErrorType\n\nfunction formatAbiParam(\n  param: AbiParameter,\n  { includeName }: { includeName: boolean },\n): string {\n  if (param.type.startsWith('tuple')) {\n    return `(${formatAbiParams(\n      (param as unknown as { components: AbiParameter[] }).components,\n      { includeName },\n    )})${param.type.slice('tuple'.length)}`\n  }\n  return param.type + (includeName && param.name ? ` ${param.name}` : '')\n}\n","import type { AbiFunction } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type ToSignatureHashErrorType,\n  toSignatureHash,\n} from './toSignatureHash.js'\n\nexport type ToFunctionSelectorErrorType =\n  | ToSignatureHashErrorType\n  | SliceErrorType\n  | ErrorType\n\n/**\n * Returns the function selector for a given function definition.\n *\n * @example\n * const selector = toFunctionSelector('function ownerOf(uint256 tokenId)')\n * // 0x6352211e\n */\nexport const toFunctionSelector = (fn: string | AbiFunction) =>\n  slice(toSignatureHash(fn), 0, 4)\n","import type { Address } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { LruMap } from '../lru.js'\nimport { checksumAddress } from './getAddress.js'\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/\n\n/** @internal */\nexport const isAddressCache = /*#__PURE__*/ new LruMap<boolean>(8192)\n\nexport type IsAddressOptions = {\n  /**\n   * Enables strict mode. Whether or not to compare the address against its checksum.\n   *\n   * @default true\n   */\n  strict?: boolean | undefined\n}\n\nexport type IsAddressErrorType = ErrorType\n\nexport function isAddress(\n  address: string,\n  options?: IsAddressOptions | undefined,\n): address is Address {\n  const { strict = true } = options ?? {}\n  const cacheKey = `${address}.${strict}`\n\n  if (isAddressCache.has(cacheKey)) return isAddressCache.get(cacheKey)!\n\n  const result = (() => {\n    if (!addressRegex.test(address)) return false\n    if (address.toLowerCase() === address) return true\n    if (strict) return checksumAddress(address as Address) === address\n    return true\n  })()\n  isAddressCache.set(cacheKey, result)\n  return result\n}\n","import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport { execTyped } from '../regex.js'\nimport type { IsNarrowable, Join } from '../types.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * type Result = FormatAbiParameter<{ type: 'address'; name: 'from'; }>\n * //   ^? type Result = 'address from'\n */\nexport type FormatAbiParameter<\n  abiParameter extends AbiParameter | AbiEventParameter,\n> = abiParameter extends {\n  name?: infer name extends string\n  type: `tuple${infer array}`\n  components: infer components extends readonly AbiParameter[]\n  indexed?: infer indexed extends boolean\n}\n  ? FormatAbiParameter<\n      {\n        type: `(${Join<\n          {\n            [key in keyof components]: FormatAbiParameter<\n              {\n                type: components[key]['type']\n              } & (IsNarrowable<components[key]['name'], string> extends true\n                ? { name: components[key]['name'] }\n                : unknown) &\n                (components[key] extends { components: readonly AbiParameter[] }\n                  ? { components: components[key]['components'] }\n                  : unknown)\n            >\n          },\n          ', '\n        >})${array}`\n      } & (IsNarrowable<name, string> extends true ? { name: name } : unknown) &\n        (IsNarrowable<indexed, boolean> extends true\n          ? { indexed: indexed }\n          : unknown)\n    >\n  : `${abiParameter['type']}${abiParameter extends { indexed: true }\n      ? ' indexed'\n      : ''}${abiParameter['name'] extends infer name extends string\n      ? name extends ''\n        ? ''\n        : ` ${AssertName<name>}`\n      : ''}`\n\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter<\n  const abiParameter extends AbiParameter | AbiEventParameter,\n>(abiParameter: abiParameter): FormatAbiParameter<abiParameter> {\n  type Result = FormatAbiParameter<abiParameter>\n\n  let type = abiParameter.type\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n    type = '('\n    const length = abiParameter.components.length as number\n    for (let i = 0; i < length; i++) {\n      const component = abiParameter.components[i]!\n      type += formatAbiParameter(component)\n      if (i < length - 1) type += ', '\n    }\n    const result = execTyped<{ array?: string }>(tupleRegex, abiParameter.type)\n    type += `)${result?.array ?? ''}`\n    return formatAbiParameter({\n      ...abiParameter,\n      type,\n    }) as Result\n  }\n  // Add `indexed` to type if in `abiParameter`\n  if ('indexed' in abiParameter && abiParameter.indexed)\n    type = `${type} indexed`\n  // Return human-readable ABI parameter\n  if (abiParameter.name) return `${type} ${abiParameter.name}` as Result\n  return type as Result\n}\n","import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport type { Join } from '../types.js'\nimport {\n  type FormatAbiParameter,\n  formatAbiParameter,\n} from './formatAbiParameter.js'\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameter.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * type Result = FormatAbiParameters<[\n *   // ^? type Result = 'address from, uint256 tokenId'\n *   { type: 'address'; name: 'from'; },\n *   { type: 'uint256'; name: 'tokenId'; },\n * ]>\n */\nexport type FormatAbiParameters<\n  abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n> = Join<\n  {\n    [key in keyof abiParameters]: FormatAbiParameter<abiParameters[key]>\n  },\n  ', '\n>\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameters.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * const result = formatAbiParameters([\n *   //  ^? const result: 'address from, uint256 tokenId'\n *   { type: 'address', name: 'from' },\n *   { type: 'uint256', name: 'tokenId' },\n * ])\n */\nexport function formatAbiParameters<\n  const abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n>(abiParameters: abiParameters): FormatAbiParameters<abiParameters> {\n  let params = ''\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    params += formatAbiParameter(abiParameter)\n    if (i !== length - 1) params += ', '\n  }\n  return params as FormatAbiParameters<abiParameters>\n}\n","export const presignMessagePrefix = '\\x19Ethereum Signed Message:\\n'\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, SignableMessage } from '../../types/misc.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { toPrefixedMessage } from './toPrefixedMessage.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type HashMessageReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type HashMessageErrorType = Keccak256ErrorType | ErrorType\n\nexport function hashMessage<to extends To = 'hex'>(\n  message: SignableMessage,\n  to_?: to | undefined,\n): HashMessageReturnType<to> {\n  return keccak256(toPrefixedMessage(message), to_)\n}\n","import { presignMessagePrefix } from '../../constants/strings.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex, SignableMessage } from '../../types/misc.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { size } from '../data/size.js'\nimport {\n  type BytesToHexErrorType,\n  bytesToHex,\n  type StringToHexErrorType,\n  stringToHex,\n} from '../encoding/toHex.js'\n\nexport type ToPrefixedMessageErrorType =\n  | ConcatErrorType\n  | StringToHexErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\nexport function toPrefixedMessage(message_: SignableMessage): Hex {\n  const message = (() => {\n    if (typeof message_ === 'string') return stringToHex(message_)\n    if (typeof message_.raw === 'string') return message_.raw\n    return bytesToHex(message_.raw)\n  })()\n  const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`)\n  return concat([prefix, message])\n}\n","import type {\n  Abi,\n  AbiConstructor,\n  AbiError,\n  AbiEvent,\n  AbiEventParameter,\n  AbiFallback,\n  AbiFunction,\n  AbiParameter,\n  AbiReceive,\n  AbiStateMutability,\n} from '../abi.js'\nimport {\n  type FormatAbiParameters as FormatAbiParameters_,\n  formatAbiParameters,\n} from './formatAbiParameters.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport type FormatAbiItem<abiItem extends Abi[number]> =\n  Abi[number] extends abiItem\n    ? string\n    :\n        | (abiItem extends AbiFunction\n            ? AbiFunction extends abiItem\n              ? string\n              : `function ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends Exclude<\n                  AbiStateMutability,\n                  'nonpayable'\n                >\n                  ? ` ${abiItem['stateMutability']}`\n                  : ''}${abiItem['outputs']['length'] extends 0\n                  ? ''\n                  : ` returns (${FormatAbiParameters<abiItem['outputs']>})`}`\n            : never)\n        | (abiItem extends AbiEvent\n            ? AbiEvent extends abiItem\n              ? string\n              : `event ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiError\n            ? AbiError extends abiItem\n              ? string\n              : `error ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiConstructor\n            ? AbiConstructor extends abiItem\n              ? string\n              : `constructor(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (abiItem extends AbiFallback\n            ? AbiFallback extends abiItem\n              ? string\n              : `fallback() external${abiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (abiItem extends AbiReceive\n            ? AbiReceive extends abiItem\n              ? string\n              : 'receive() external payable'\n            : never)\n\ntype FormatAbiParameters<\n  abiParameters extends readonly (AbiParameter | AbiEventParameter)[],\n> = abiParameters['length'] extends 0\n  ? ''\n  : FormatAbiParameters_<\n      abiParameters extends readonly [\n        AbiParameter | AbiEventParameter,\n        ...(readonly (AbiParameter | AbiEventParameter)[]),\n      ]\n        ? abiParameters\n        : never\n    >\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport function formatAbiItem<const abiItem extends Abi[number]>(\n  abiItem: abiItem,\n): FormatAbiItem<abiItem> {\n  type Result = FormatAbiItem<abiItem>\n  type Params = readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ]\n\n  if (abiItem.type === 'function')\n    return `function ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})${\n      abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'\n        ? ` ${abiItem.stateMutability}`\n        : ''\n    }${\n      abiItem.outputs?.length\n        ? ` returns (${formatAbiParameters(abiItem.outputs as Params)})`\n        : ''\n    }`\n  if (abiItem.type === 'event')\n    return `event ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'error')\n    return `error ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'constructor')\n    return `constructor(${formatAbiParameters(abiItem.inputs as Params)})${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }`\n  if (abiItem.type === 'fallback')\n    return `fallback() external${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }` as Result\n  return 'receive() external payable' as Result\n}\n","import { keccak_256 } from '@noble/hashes/sha3'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Keccak256Hash<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type Keccak256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function keccak256<to extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: to | undefined,\n): Keccak256Hash<to> {\n  const to = to_ || 'hex'\n  const bytes = keccak_256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Keccak256Hash<to>\n  return toHex(bytes) as Keccak256Hash<to>\n}\n","import type { TypedData } from 'abitype'\n\nimport { stringify } from '../utils/stringify.js'\nimport { BaseError } from './base.js'\n\nexport type InvalidDomainErrorType = InvalidDomainError & {\n  name: 'InvalidDomainError'\n}\nexport class InvalidDomainError extends BaseError {\n  constructor({ domain }: { domain: unknown }) {\n    super(`Invalid domain \"${stringify(domain)}\".`, {\n      metaMessages: ['Must be a valid EIP-712 domain.'],\n    })\n  }\n}\n\nexport type InvalidPrimaryTypeErrorType = InvalidPrimaryTypeError & {\n  name: 'InvalidPrimaryTypeError'\n}\nexport class InvalidPrimaryTypeError extends BaseError {\n  constructor({\n    primaryType,\n    types,\n  }: { primaryType: string; types: TypedData | Record<string, unknown> }) {\n    super(\n      `Invalid primary type \\`${primaryType}\\` must be one of \\`${JSON.stringify(Object.keys(types))}\\`.`,\n      {\n        docsPath: '/api/glossary/Errors#typeddatainvalidprimarytypeerror',\n        metaMessages: ['Check that the primary type is a key in `types`.'],\n      },\n    )\n  }\n}\n\nexport type InvalidStructTypeErrorType = InvalidStructTypeError & {\n  name: 'InvalidStructTypeError'\n}\nexport class InvalidStructTypeError extends BaseError {\n  constructor({ type }: { type: string }) {\n    super(`Struct type \"${type}\" is invalid.`, {\n      metaMessages: ['Struct type must not be a Solidity type.'],\n      name: 'InvalidStructTypeError',\n    })\n  }\n}\n","import type { TypedData, TypedDataDomain, TypedDataParameter } from 'abitype'\n\nimport { BytesSizeMismatchError } from '../errors/abi.js'\nimport { InvalidAddressError } from '../errors/address.js'\nimport {\n  InvalidDomainError,\n  InvalidPrimaryTypeError,\n  InvalidStructTypeError,\n} from '../errors/typedData.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { Hex } from '../types/misc.js'\nimport type { TypedDataDefinition } from '../types/typedData.js'\nimport { type IsAddressErrorType, isAddress } from './address/isAddress.js'\nimport { type SizeErrorType, size } from './data/size.js'\nimport { type NumberToHexErrorType, numberToHex } from './encoding/toHex.js'\nimport { bytesRegex, integerRegex } from './regex.js'\nimport {\n  type HashDomainErrorType,\n  hashDomain,\n} from './signature/hashTypedData.js'\nimport { stringify } from './stringify.js'\n\nexport type SerializeTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function serializeTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const {\n    domain: domain_,\n    message: message_,\n    primaryType,\n    types,\n  } = parameters as unknown as TypedDataDefinition\n\n  const normalizeData = (\n    struct: readonly TypedDataParameter[],\n    data_: Record<string, unknown>,\n  ) => {\n    const data = { ...data_ }\n    for (const param of struct) {\n      const { name, type } = param\n      if (type === 'address') data[name] = (data[name] as string).toLowerCase()\n    }\n    return data\n  }\n\n  const domain = (() => {\n    if (!types.EIP712Domain) return {}\n    if (!domain_) return {}\n    return normalizeData(types.EIP712Domain, domain_)\n  })()\n\n  const message = (() => {\n    if (primaryType === 'EIP712Domain') return undefined\n    return normalizeData(types[primaryType], message_)\n  })()\n\n  return stringify({ domain, message, primaryType, types })\n}\n\nexport type ValidateTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function validateTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const { domain, message, primaryType, types } =\n    parameters as unknown as TypedDataDefinition\n\n  const validateData = (\n    struct: readonly TypedDataParameter[],\n    data: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type } = param\n      const value = data[name]\n\n      const integerMatch = type.match(integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [_type, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_, 10) / 8,\n        })\n      }\n\n      if (type === 'address' && typeof value === 'string' && !isAddress(value))\n        throw new InvalidAddressError({ address: value })\n\n      const bytesMatch = type.match(bytesRegex)\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch\n        if (size_ && size(value as Hex) !== Number.parseInt(size_, 10))\n          throw new BytesSizeMismatchError({\n            expectedSize: Number.parseInt(size_, 10),\n            givenSize: size(value as Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) {\n        validateReference(type)\n        validateData(struct, value as Record<string, unknown>)\n      }\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) {\n    if (typeof domain !== 'object') throw new InvalidDomainError({ domain })\n    validateData(types.EIP712Domain, domain)\n  }\n\n  // Validate message types.\n  if (primaryType !== 'EIP712Domain') {\n    if (types[primaryType]) validateData(types[primaryType], message)\n    else throw new InvalidPrimaryTypeError({ primaryType, types })\n  }\n}\n\nexport type GetTypesForEIP712DomainErrorType = ErrorType\n\nexport function getTypesForEIP712Domain({\n  domain,\n}: {\n  domain?: TypedDataDomain | undefined\n}): TypedDataParameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    (typeof domain?.chainId === 'number' ||\n      typeof domain?.chainId === 'bigint') && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as TypedDataParameter[]\n}\n\nexport type DomainSeparatorErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | ErrorType\n\nexport function domainSeparator({ domain }: { domain: TypedDataDomain }): Hex {\n  return hashDomain({\n    domain,\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\n    },\n  })\n}\n\n/** @internal */\nfunction validateReference(type: string) {\n  // Struct type must not be a Solidity type.\n  if (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'string' ||\n    type.startsWith('bytes') ||\n    type.startsWith('uint') ||\n    type.startsWith('int')\n  )\n    throw new InvalidStructTypeError({ type })\n}\n","// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\n\nimport type { AbiParameter, TypedData, TypedDataDomain } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from '../abi/encodeAbiParameters.js'\nimport { concat } from '../data/concat.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type GetTypesForEIP712DomainErrorType,\n  getTypesForEIP712Domain,\n  type ValidateTypedDataErrorType,\n  validateTypedData,\n} from '../typedData.js'\n\ntype MessageTypeProperty = {\n  name: string\n  type: string\n}\n\nexport type HashTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType>\n\nexport type HashTypedDataReturnType = Hex\n\nexport type HashTypedDataErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | HashStructErrorType\n  | ValidateTypedDataErrorType\n  | ErrorType\n\nexport function hashTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: HashTypedDataParameters<typedData, primaryType>,\n): HashTypedDataReturnType {\n  const {\n    domain = {},\n    message,\n    primaryType,\n  } = parameters as HashTypedDataParameters\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({ domain }),\n    ...parameters.types,\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types,\n  })\n\n  const parts: Hex[] = ['0x1901']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  if (primaryType !== 'EIP712Domain')\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  return keccak256(concat(parts))\n}\n\nexport type HashDomainErrorType = HashStructErrorType | ErrorType\n\nexport function hashDomain({\n  domain,\n  types,\n}: {\n  domain: TypedDataDomain\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types,\n  })\n}\n\nexport type HashStructErrorType =\n  | EncodeDataErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nexport function hashStruct({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return keccak256(encoded)\n}\n\ntype EncodeDataErrorType =\n  | EncodeAbiParametersErrorType\n  | EncodeFieldErrorType\n  | HashTypeErrorType\n  | ErrorType\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedTypes: AbiParameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues)\n}\n\ntype HashTypeErrorType =\n  | ToHexErrorType\n  | EncodeTypeErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }))\n  return keccak256(encodedHashType)\n}\n\ntype EncodeTypeErrorType = FindTypeDependenciesErrorType\n\nexport function encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\ntype FindTypeDependenciesErrorType = ErrorType\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string\n    types: Record<string, readonly MessageTypeProperty[]>\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results\n  }\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  }\n  return results\n}\n\ntype EncodeFieldErrorType =\n  | Keccak256ErrorType\n  | EncodeAbiParametersErrorType\n  | ToHexErrorType\n  | ErrorType\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, readonly MessageTypeProperty[]>\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: 'bytes32' },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n  }\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, keccak256(value)]\n  }\n\n  if (type === 'string') return [{ type: 'bytes32' }, keccak256(toHex(value))]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameter, any][]).map((item) =>\n      encodeField({\n        name,\n        type: parsedType,\n        types,\n        value: item,\n      }),\n    )\n    return [\n      { type: 'bytes32' },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n","import type { Abi, AbiEvent, AbiParameter } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js'\nimport { size } from '../utils/data/size.js'\n\nimport { BaseError } from './base.js'\n\nexport type AbiConstructorNotFoundErrorType = AbiConstructorNotFoundError & {\n  name: 'AbiConstructorNotFoundError'\n}\nexport class AbiConstructorNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'A constructor was not found on the ABI.',\n        'Make sure you are using the correct ABI and that the constructor exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiConstructorNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiConstructorParamsNotFoundErrorType =\n  AbiConstructorParamsNotFoundError & {\n    name: 'AbiConstructorParamsNotFoundError'\n  }\n\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n        'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiConstructorParamsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeInvalidErrorType =\n  AbiDecodingDataSizeInvalidError & {\n    name: 'AbiDecodingDataSizeInvalidError'\n  }\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n  constructor({ data, size }: { data: Hex; size: number }) {\n    super(\n      [\n        `Data size of ${size} bytes is invalid.`,\n        'Size must be in increments of 32 bytes (size % 32 === 0).',\n      ].join('\\n'),\n      {\n        metaMessages: [`Data: ${data} (${size} bytes)`],\n        name: 'AbiDecodingDataSizeInvalidError',\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeTooSmallErrorType =\n  AbiDecodingDataSizeTooSmallError & {\n    name: 'AbiDecodingDataSizeTooSmallError'\n  }\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    data,\n    params,\n    size,\n  }: { data: Hex; params: readonly AbiParameter[]; size: number }) {\n    super(\n      [`Data size of ${size} bytes is too small for given parameters.`].join(\n        '\\n',\n      ),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n        name: 'AbiDecodingDataSizeTooSmallError',\n      },\n    )\n\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type AbiDecodingZeroDataErrorType = AbiDecodingZeroDataError & {\n  name: 'AbiDecodingZeroDataError'\n}\nexport class AbiDecodingZeroDataError extends BaseError {\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.', {\n      name: 'AbiDecodingZeroDataError',\n    })\n  }\n}\n\nexport type AbiEncodingArrayLengthMismatchErrorType =\n  AbiEncodingArrayLengthMismatchError & {\n    name: 'AbiEncodingArrayLengthMismatchError'\n  }\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n    type,\n  }: { expectedLength: number; givenLength: number; type: string }) {\n    super(\n      [\n        `ABI encoding array length mismatch for type ${type}.`,\n        `Expected length: ${expectedLength}`,\n        `Given length: ${givenLength}`,\n      ].join('\\n'),\n      { name: 'AbiEncodingArrayLengthMismatchError' },\n    )\n  }\n}\n\nexport type AbiEncodingBytesSizeMismatchErrorType =\n  AbiEncodingBytesSizeMismatchError & {\n    name: 'AbiEncodingBytesSizeMismatchError'\n  }\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n  constructor({ expectedSize, value }: { expectedSize: number; value: Hex }) {\n    super(\n      `Size of bytes \"${value}\" (bytes${size(\n        value,\n      )}) does not match expected size (bytes${expectedSize}).`,\n      { name: 'AbiEncodingBytesSizeMismatchError' },\n    )\n  }\n}\n\nexport type AbiEncodingLengthMismatchErrorType =\n  AbiEncodingLengthMismatchError & {\n    name: 'AbiEncodingLengthMismatchError'\n  }\nexport class AbiEncodingLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n  }: { expectedLength: number; givenLength: number }) {\n    super(\n      [\n        'ABI encoding params/values length mismatch.',\n        `Expected length (params): ${expectedLength}`,\n        `Given length (values): ${givenLength}`,\n      ].join('\\n'),\n      { name: 'AbiEncodingLengthMismatchError' },\n    )\n  }\n}\n\nexport type AbiErrorInputsNotFoundErrorType = AbiErrorInputsNotFoundError & {\n  name: 'AbiErrorInputsNotFoundError'\n}\nexport class AbiErrorInputsNotFoundError extends BaseError {\n  constructor(errorName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n        'Cannot encode error result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the inputs exist on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorInputsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiErrorNotFoundErrorType = AbiErrorNotFoundError & {\n  name: 'AbiErrorNotFoundError'\n}\nexport class AbiErrorNotFoundError extends BaseError {\n  constructor(\n    errorName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiErrorSignatureNotFoundErrorType =\n  AbiErrorSignatureNotFoundError & {\n    name: 'AbiErrorSignatureNotFoundError'\n  }\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n  signature: Hex\n\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded error signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorSignatureNotFoundError',\n      },\n    )\n    this.signature = signature\n  }\n}\n\nexport type AbiEventSignatureEmptyTopicsErrorType =\n  AbiEventSignatureEmptyTopicsError & {\n    name: 'AbiEventSignatureEmptyTopicsError'\n  }\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super('Cannot extract event signature from empty topics.', {\n      docsPath,\n      name: 'AbiEventSignatureEmptyTopicsError',\n    })\n  }\n}\n\nexport type AbiEventSignatureNotFoundErrorType =\n  AbiEventSignatureNotFoundError & {\n    name: 'AbiEventSignatureNotFoundError'\n  }\nexport class AbiEventSignatureNotFoundError extends BaseError {\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded event signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiEventSignatureNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiEventNotFoundErrorType = AbiEventNotFoundError & {\n  name: 'AbiEventNotFoundError'\n}\nexport class AbiEventNotFoundError extends BaseError {\n  constructor(\n    eventName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiEventNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionNotFoundErrorType = AbiFunctionNotFoundError & {\n  name: 'AbiFunctionNotFoundError'\n}\nexport class AbiFunctionNotFoundError extends BaseError {\n  constructor(\n    functionName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionOutputsNotFoundErrorType =\n  AbiFunctionOutputsNotFoundError & {\n    name: 'AbiFunctionOutputsNotFoundError'\n  }\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n  constructor(functionName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n        'Cannot decode function result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionOutputsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionSignatureNotFoundErrorType =\n  AbiFunctionSignatureNotFoundError & {\n    name: 'AbiFunctionSignatureNotFoundError'\n  }\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded function signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionSignatureNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiItemAmbiguityErrorType = AbiItemAmbiguityError & {\n  name: 'AbiItemAmbiguityError'\n}\nexport class AbiItemAmbiguityError extends BaseError {\n  constructor(\n    x: { abiItem: Abi[number]; type: string },\n    y: { abiItem: Abi[number]; type: string },\n  ) {\n    super('Found ambiguous types in overloaded ABI items.', {\n      metaMessages: [\n        `\\`${x.type}\\` in \\`${formatAbiItem(x.abiItem)}\\`, and`,\n        `\\`${y.type}\\` in \\`${formatAbiItem(y.abiItem)}\\``,\n        '',\n        'These types encode differently and cannot be distinguished at runtime.',\n        'Remove one of the ambiguous items in the ABI.',\n      ],\n      name: 'AbiItemAmbiguityError',\n    })\n  }\n}\n\nexport type BytesSizeMismatchErrorType = BytesSizeMismatchError & {\n  name: 'BytesSizeMismatchError'\n}\nexport class BytesSizeMismatchError extends BaseError {\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {\n      name: 'BytesSizeMismatchError',\n    })\n  }\n}\n\nexport type DecodeLogDataMismatchErrorType = DecodeLogDataMismatch & {\n  name: 'DecodeLogDataMismatch'\n}\nexport class DecodeLogDataMismatch extends BaseError {\n  abiItem: AbiEvent\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    abiItem,\n    data,\n    params,\n    size,\n  }: {\n    abiItem: AbiEvent\n    data: Hex\n    params: readonly AbiParameter[]\n    size: number\n  }) {\n    super(\n      [\n        `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n      ].join('\\n'),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n        name: 'DecodeLogDataMismatch',\n      },\n    )\n\n    this.abiItem = abiItem\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type DecodeLogTopicsMismatchErrorType = DecodeLogTopicsMismatch & {\n  name: 'DecodeLogTopicsMismatch'\n}\nexport class DecodeLogTopicsMismatch extends BaseError {\n  abiItem: AbiEvent\n\n  constructor({\n    abiItem,\n    param,\n  }: {\n    abiItem: AbiEvent\n    param: AbiParameter & { indexed: boolean }\n  }) {\n    super(\n      [\n        `Expected a topic for indexed event parameter${\n          param.name ? ` \"${param.name}\"` : ''\n        } on event \"${formatAbiItem(abiItem, { includeName: true })}\".`,\n      ].join('\\n'),\n      { name: 'DecodeLogTopicsMismatch' },\n    )\n\n    this.abiItem = abiItem\n  }\n}\n\nexport type InvalidAbiEncodingTypeErrorType = InvalidAbiEncodingTypeError & {\n  name: 'InvalidAbiEncodingTypeError'\n}\nexport class InvalidAbiEncodingTypeError extends BaseError {\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid encoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath, name: 'InvalidAbiEncodingType' },\n    )\n  }\n}\n\nexport type InvalidAbiDecodingTypeErrorType = InvalidAbiDecodingTypeError & {\n  name: 'InvalidAbiDecodingTypeError'\n}\nexport class InvalidAbiDecodingTypeError extends BaseError {\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid decoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath, name: 'InvalidAbiDecodingType' },\n    )\n  }\n}\n\nexport type InvalidArrayErrorType = InvalidArrayError & {\n  name: 'InvalidArrayError'\n}\nexport class InvalidArrayError extends BaseError {\n  constructor(value: unknown) {\n    super([`Value \"${value}\" is not a valid array.`].join('\\n'), {\n      name: 'InvalidArrayError',\n    })\n  }\n}\n\nexport type InvalidDefinitionTypeErrorType = InvalidDefinitionTypeError & {\n  name: 'InvalidDefinitionTypeError'\n}\nexport class InvalidDefinitionTypeError extends BaseError {\n  constructor(type: string) {\n    super(\n      [\n        `\"${type}\" is not a valid definition type.`,\n        'Valid types: \"function\", \"event\", \"error\"',\n      ].join('\\n'),\n      { name: 'InvalidDefinitionTypeError' },\n    )\n  }\n}\n\nexport type UnsupportedPackedAbiTypeErrorType = UnsupportedPackedAbiType & {\n  name: 'UnsupportedPackedAbiType'\n}\nexport class UnsupportedPackedAbiType extends BaseError {\n  constructor(type: unknown) {\n    super(`Type \"${type}\" is not supported for packed encoding.`, {\n      name: 'UnsupportedPackedAbiType',\n    })\n  }\n}\n"],"names":["getAbiItem","parameters","abi","args","name","isSelector","isHex","strict","abiItems","filter","abiItem","type","toFunctionSelector","toEventSelector","length","matchedAbiItem","inputs","every","arg","index","abiParameter","isArgOfType","ambiguousTypes","getAmbiguousTypes","AbiItemAmbiguityError","argType","abiParameterType","isAddress","Object","values","components","component","test","Uint8Array","Array","isArray","x","_objectSpread","replace","sourceParameters","targetParameters","parameterIndex","sourceParameter","targetParameter","types","includes","InvalidAddressError","BaseError","constructor","_ref","address","super","concat","metaMessages","bytesRegex","integerRegex","docsPath","encodeFunctionData","functionName","_parameters$functionN","startsWith","item","AbiFunctionNotFoundError","undefined","formatAbiItem","prepareEncodeFunctionData","signature","data","encodeAbiParameters","concatHex","toSignatureHash","params","AbiEncodingLengthMismatchError","expectedLength","givenLength","preparedParams","i","push","prepareParam","param","value","prepareParams","encodeParams","_ref2","arrayComponents","getArrayComponents","_ref3","dynamic","InvalidArrayError","AbiEncodingArrayLengthMismatchError","dynamicChild","preparedParam","numberToHex","size","encoded","map","_ref4","encodeArray","_ref7","param_","_ref8","encodeTuple","padHex","toLowerCase","encodeAddress","boolToHex","encodeBool","_integerRegex$exec","signed","exec","_ref6","max","BigInt","min","IntegerOutOfRangeError","toString","encodeNumber","Number","_ref5","paramSize","split","bytesSize","value_","dir","Math","ceil","parseInt","AbiEncodingBytesSizeMismatchError","expectedSize","encodeBytes","hexValue","stringToHex","partsLength","parts","slice","encodeString","InvalidAbiEncodingTypeError","staticSize","staticParams","dynamicParams","dynamicSize","matches","match","start","end","arguments","assertStartOffset","assertEndOffset","sliceHex","sliceBytes","SliceOffsetOutOfBoundsError","offset","position","encoder","TextEncoder","toBytes","opts","hex","hexToBytes","numberToBytes","bytes","assertSize","pad","boolToBytes","stringToBytes","charCodeMap","zero","nine","A","F","a","f","charCodeToBase16","char","hex_","hexString","j","nibbleLeft","charCodeAt","nibbleRight","encode","execTyped","regex","string","groups","isTupleRegex","checksumAddressCache","LruMap","checksumAddress","address_","chainId","has","get","hexAddress","substring","hash","keccak256","toUpperCase","result","join","set","getAddress","toSignature","def","active","current","level","valid","normalizeSignature","fn","sig","arr","concatBytes","reduce","acc","includeName","InvalidDefinitionTypeError","formatAbiParams","formatAbiParam","addressRegex","isAddressCache","options","cacheKey","tupleRegex","_wrapRegExp","array","formatAbiParameter","_result$array","indexed","formatAbiParameters","abiParameters","presignMessagePrefix","hashMessage","message","to_","message_","raw","bytesToHex","prefix","toPrefixedMessage","_abiItem$outputs","stateMutability","outputs","to","keccak_256","toHex","InvalidDomainError","domain","stringify","InvalidPrimaryTypeError","primaryType","JSON","keys","InvalidStructTypeError","getTypesForEIP712Domain","version","verifyingContract","salt","Boolean","validateReference","hashTypedData","EIP712Domain","validateData","struct","integerMatch","_type","base","size_","bytesMatch","BytesSizeMismatchError","givenSize","validateTypedData","hashStruct","hashDomain","encodeData","encodedTypes","encodedValues","hashType","field","encodeField","encodedHashType","unsortedDeps","findTypeDependencies","delete","deps","from","sort","t","encodeType","primaryType_","results","Set","add","prepend","lastIndexOf","parsedType","typeValuePairs","_ref9","_ref0","v","AbiConstructorNotFoundError","AbiConstructorParamsNotFoundError","AbiDecodingDataSizeTooSmallError","defineProperty","this","AbiDecodingZeroDataError","AbiErrorInputsNotFoundError","errorName","AbiErrorNotFoundError","AbiErrorSignatureNotFoundError","AbiEventSignatureEmptyTopicsError","AbiEventSignatureNotFoundError","_ref1","AbiEventNotFoundError","eventName","AbiFunctionOutputsNotFoundError","_ref10","AbiFunctionSignatureNotFoundError","_ref11","y","_ref12","DecodeLogDataMismatch","_ref13","DecodeLogTopicsMismatch","_ref14","_ref15","InvalidAbiDecodingTypeError","_ref16"],"sourceRoot":""}